#include <iostream>
#include <cmath>
#include <vector>
#include <fstream>
int main(){[]{std::vector<std::vector<std::tuple<float,float,float>>> v(256,std::vector<std::tuple<float,float,float>>(256,std::tuple(0.f,0.f,0.f)));for(int y=0;y<256;y++)for(int x=0;x<256;x++){auto n=[](auto v){auto[x,y,z]=v;float l=std::sqrt(x*x+y*y+z*z);return std::tuple(x/l,y/l,z/l);};auto d=[](auto v1,auto v2){auto[x1,y1,z1]=v1;auto[x2,y2,z2]=v2;return x1*x2+y1*y2+z1*z2;};auto sphere_hit=[&](auto o,auto dir,auto c,float rad){auto oc=std::tuple(std::get<0>(o)-std::get<0>(c),std::get<1>(o)-std::get<1>(c),std::get<2>(o)-std::get<2>(c));float a=d(dir,dir),b=2.f*d(oc,dir),c_val=d(oc,oc)-rad*rad,disc=b*b-4.f*a*c_val;return disc>0.f?(-b-std::sqrt(disc))/(2.f*a):-1.f;};auto plane_hit=[&](auto o,auto dir,auto norm,float dist){float denom=d(norm,dir);if(std::abs(denom)>1e-6f){float t=-(d(norm,o)+dist)/denom;return t>0.f?t:-1.f;}return -1.f;};auto light_pos=std::tuple(5.f,5.f,0.f);auto dir=n(std::tuple(x/128.f-1.f,y/128.f-1.f,1.f));auto orig=std::tuple(0.f,0.f,0.f);auto sphere_pos=std::tuple(0.f,0.f,5.f);auto plane_norm=std::tuple(0.f,1.f,0.f);float plane_dist=-1.5f;float t_sphere=sphere_hit(orig,dir,sphere_pos,1.f);float t_plane=plane_hit(orig,dir,plane_norm,plane_dist);v[y][x]=[&]()->std::tuple<float,float,float>{if(t_sphere>0.f&&(t_plane<=0.f||t_sphere<t_plane)){auto hit=std::tuple(std::get<0>(orig)+std::get<0>(dir)*t_sphere,std::get<1>(orig)+std::get<1>(dir)*t_sphere,std::get<2>(orig)+std::get<2>(dir)*t_sphere);auto normal=n(std::tuple(std::get<0>(hit)-std::get<0>(sphere_pos),std::get<1>(hit)-std::get<1>(sphere_pos),std::get<2>(hit)-std::get<2>(sphere_pos)));auto light_dir=n(std::tuple(std::get<0>(light_pos)-std::get<0>(hit),std::get<1>(light_pos)-std::get<1>(hit),std::get<2>(light_pos)-std::get<2>(hit)));float diff=std::max(0.f,d(normal,light_dir));bool shadow=sphere_hit(hit,light_dir,sphere_pos,1.f)>0.001f||plane_hit(hit,light_dir,plane_norm,plane_dist)>0.001f;float r=0.2f,g=0.3f,b=0.8f,ambient=0.1f,intensity=shadow?ambient:ambient+diff*0.9f;return std::tuple<float,float,float>(r*intensity,g*intensity,b*intensity);}else if(t_plane>0.f){auto hit=std::tuple(std::get<0>(orig)+std::get<0>(dir)*t_plane,std::get<1>(orig)+std::get<1>(dir)*t_plane,std::get<2>(orig)+std::get<2>(dir)*t_plane);auto light_dir=n(std::tuple(std::get<0>(light_pos)-std::get<0>(hit),std::get<1>(light_pos)-std::get<1>(hit),std::get<2>(light_pos)-std::get<2>(hit)));float diff=std::max(0.f,d(plane_norm,light_dir));bool shadow=sphere_hit(hit,light_dir,sphere_pos,1.f)>0.001f;bool is_white=(int(std::floor(std::get<0>(hit)))%2)^(int(std::floor(std::get<2>(hit)))%2);float r=is_white?0.9f:0.4f,g=r,b=r,ambient=0.1f,intensity=shadow?ambient:ambient+diff*0.9f;return std::tuple<float,float,float>(r*intensity,g*intensity,b*intensity);}else return std::tuple<float,float,float>(0.2f,0.7f,0.8f);}();}std::ofstream file("output.ppm");file<<"P3\n256 256\n255\n";for(int y=0;y<256;y++){for(int x=0;x<256;x++){file<<int(std::get<0>(v[y][x])*255)<<" "<<int(std::get<1>(v[y][x])*255)<<" "<<int(std::get<2>(v[y][x])*255)<<" ";}file<<"\n";}}();return 0;}